<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Jose M. Perez&#39;s Blog</title>
  <subtitle>Web development, performance, and some other good practices.</subtitle>
  <link href="/tag/ux/atom.xml" rel="self"/>
  
  <link href="https://jmperezperez.com/"/>
  <updated>2018-12-16T17:51:46.000Z</updated>
  <id>https://jmperezperez.com/</id>
  
  <author>
    <name>Jose M. Perez</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Drawing images using edge detection and SVG animation</title>
    <link href="https://jmperezperez.com//drawing-edges-svg"/>
    <id>https://jmperezperez.com//drawing-edges-svg</id>
    <published>2015-12-18T08:42:00.000Z</published>
    <updated>2018-12-16T17:51:46.000Z</updated>
    
    <content type="html"><![CDATA[<p>Back in the days SVG was barely used and supported. Some time after we started using them as an alternative to classic bitmaps for some icons, and finally we discovered it was the holy grail for providing responsive graphics. The flat and clean design trends have also make SVG as a very useful image format.</p>
<p>But SVG allows for even cooler features, thanks to the ability of modifying it using CSS and JS. And with some clever techniques we can make fun things, like <em>drawing</em> the borders of an image.</p>
<span id="more"></span>
<p>If you are like me and like to see the final result before going through a wall of text, here is a video that shows the result of applying this effect to a couple of images:</p>
<video controls style="max-width:100%" width="718" height="756">
  <source src="/assets/images/posts/contour.mp4" type="video/mp4">
</video>

<h2 id="Animate-SVGs-to-achieve-a-drawing-effect"><a href="#Animate-SVGs-to-achieve-a-drawing-effect" class="headerlink" title="Animate SVGs to achieve a drawing effect"></a>Animate SVGs to achieve a <em>drawing</em> effect</h2><p>One of the applications I like is path animation. This draws slowly the lines that compose the SVG. If you don’t know what this is about, please check <a href="http://www.polygon.com/a/ps4-review">Polygon’s reviews for PS4</a> and <a href="http://www.polygon.com/a/xbox-one-review">Xbox One</a>. The effect is achieved by applying transitions to the <code>stroke-dashoffset</code> of SVG polylines.</p>
<p>Some time ago I played with <a href="https://github.com/JMPerez/spotify-logo-svg-drawing-animation">this technique and the vector version of the Spotify logo</a>:</p>
<iframe id="cp_embed_rxxRRg" src="//codepen.io/jmperez/embed/rxxRRg?height=403&theme-id=0&slug-hash=rxxRRg&default-tab=result" scrolling="no" frameborder="no" height="403" allowTransparency="true" allowfullscreen="true" class="cp_embed_iframe" data-amp-width="100%" style="width: 100%; overflow: hidden;"></iframe>

<p>This was based on <a href="http://codepen.io/derekjp/pen/KIGFe/">the SVG Animation (Polygon.com PS4 Review) pen by Derek Palladino</a>, who reproduced Polygon’s drawings.</p>
<h2 id="Applying-the-technique-to-bitmap-images"><a href="#Applying-the-technique-to-bitmap-images" class="headerlink" title="Applying the technique to bitmap images"></a>Applying the technique to bitmap images</h2><p>Then one day I started thinking of drawing the contours of bitmap images. I would detect the contours of an image using canvas, and then I would create segments of adjacent points. As expected, some smart people have already worked on these things before, and I pretty much just had to put it together.</p>
<p>That’s how I created Contour. The project is <a href="https://github.com/JMPerez/contour">on GitHub</a>, so feel free to clone it and tweak it. And if you want to try it out right now, I have embedded it right here:</p>
<iframe src="https://jmperezperez.com/contour/" width="100%" height="500"></iframe>

<p>You can drag and drop any image. It will work better with images with areas with high contrast.</p>
<p>You may wonder how this works, who doesn’t?</p>
<h3 id="Canvas"><a href="#Canvas" class="headerlink" title="Canvas"></a>Canvas</h3><p>First, the image that you drop is drawn into a canvas that has a maximum size. If the image exceeds that size, it is downscaled. This allows us to process larger images without making the browser become super slow. The smallest the canvas, the fastest, but also the less accurate would be the SVG lines.</p>
<p>Then, there is the core process: detecting edges and creating SVG lines out of them.</p>
<h3 id="Canny-edge-detector"><a href="#Canny-edge-detector" class="headerlink" title="Canny edge detector"></a>Canny edge detector</h3><p>I read about the <a href="https://en.wikipedia.org/wiki/Canny_edge_detector">Canny edge detector</a> trying to find an algorithm that detected the edges from an image, and then found a JS implementation. <a href="https://github.com/yuta1984/CannyJS">Canny JS</a> is one of them, and performs well. However, in the end I chose <a href="https://github.com/cmisenas/canny-edge-detection">Jade Misenas’s project</a> because I could visualise better the steps of the algorithm and it resulted in longer lines with fewer gaps. This is important, since we need to be able to generate SVG lines by following the pixels that are part of the edge.</p>
<p>By the way, if you want to learn more about edge detection, I recommend you to have a look at <a href="https://www.youtube.com/watch?v=uihBwtPIBxM">the video Finding the Edges (Sobel Operator)</a>, that explains one of the operators that can be used when performing edge detection.</p>
<h3 id="Tracing-the-edge"><a href="#Tracing-the-edge" class="headerlink" title="Tracing the edge"></a>Tracing the edge</h3><p>To obtain the SVG lines I used <a href="https://github.com/Doodle3D/Contour-finding-experiment">Doodle3D’s Contour finding experiment</a>, which I eventually simplified a bit. The idea is to traverse the canvas and, once we find a white pixel (edge), we follow the nearby pixels to compose the line.</p>
<p>One we have a set of lines, we create one SVG polyline per contour, using the pixels as points. There are some improvements we can do here:</p>
<ul>
<li><p>Simplify polyline to remove points that don’t contribute to the line, that is, they can fall behind a longer segment. An example is having a horizontal line spanning through several pixels, that can be defined by 2 points instead of a line with 1 point per pixel. Doing this saves potentially lots of points, especially if there are lots of vertical or horizontal lines.</p>
</li>
<li><p>Smooth the polyline to match better arcs or diagonal lines that produce a stairstep-like line. In the project this is achieved by using half of the points to draw the image. The result is not that close to the border, but helps reducing those stairstep-like lines.</p>
</li>
<li><p>Use web workers to do the detection of the contour. This would prevent the browser from freezing for a few milliseconds.</p>
</li>
</ul>
<h2 id="Applications"><a href="#Applications" class="headerlink" title="Applications"></a>Applications</h2><p>The effect is cool by itself and doesn’t take long to compute. The browser needs the image to create the SVG lines, but this could be stored somewhere and be served as inlined SVG or a standalone SVG file. And doing this we suddenly have found a way to start <em>rendering</em> an image without having downloaded it yet. Also, note that SVG is highly compressible and we have full control of how many lines and points we want to use to represent the image.</p>
<p>If you have been following this blog, I have been talking lately about techniques to load images in a progressive way, with the <a href="/medium-image-progressive-loading-placeholder/"><em>blur up</em> technique used by Medium</a> and the use of <a href="/webp-placeholder-images/">WebP as placeholders</a>.</p>
<p>So I see this drawing effect as not only a fun thing to do with images, but also a way to provide a <em>placeholder</em> while the final image is downloaded.</p>
]]></content>
    
    <summary type="html">
    
      Using SVGs to achieve a cool drawing effect
    
    </summary>
    
    
      <category term="images" scheme="https://jmperezperez.com/tags/images/"/>
    
      <category term="ux" scheme="https://jmperezperez.com/tags/ux/"/>
    
  </entry>
  
  <entry>
    <title>Using WebP to create tiny preview images</title>
    <link href="https://jmperezperez.com//webp-placeholder-images"/>
    <id>https://jmperezperez.com//webp-placeholder-images</id>
    <published>2015-11-28T10:30:00.000Z</published>
    <updated>2018-12-16T17:51:46.000Z</updated>
    
    <content type="html"><![CDATA[<p>Following with the image optimization topic, I am going to have a deeper look to <a href="https://code.facebook.com/posts/991252547593574/the-technology-behind-preview-photos/">Facebook’s technique to create <em>preview</em> photos</a>, and will show how WebP can simplify their solution.</p>
<p><img src="/assets/images/posts/webp-vs-jpeg-preview-photos.jpg" alt="WebP vs JPEG when encoding tiny images"></p>
<p><strong>tl;dr</strong> WebP produces tiny files when compressing small images. This makes it ideal for implementing <em>preview photos</em>. <a href="/demos/webp-preview/">Check the demo</a>.</p>
<span id="more"></span>
<p>In a recent article I talked about <a href="/medium-image-progressive-loading-placeholder/">an image loading technique used by Medium</a> that combined a small blurry preview plus a transition to the final image. This approach has been used for some time by other sites and mobile applications, and it is getting even more focus these days as major websites try to expand in countries with very slow internet connections.</p>
<p>Facebook is one of them and explained some months ago <a href="https://code.facebook.com/posts/991252547593574/the-technology-behind-preview-photos/">how they inlined preview photos</a>.</p>
<h2 id="Finding-out-the-right-image-dimensions"><a href="#Finding-out-the-right-image-dimensions" class="headerlink" title="Finding out the right image dimensions"></a>Finding out the right image dimensions</h2><p>There is a direct relation between the dimensions of the image, its size in bytes, and the radius for the blur effect that needs to be applied to smooth the big upscaled pixels. In addition, we need to take into account the rendered dimensions of the image: we will want a larger preview the larger the rendered size is.</p>
<p>Facebook found that, for their mobile client, the sweet spot for the preview size was 42×42px. Then, they tried to generate the smallest (in bytes) image that they could serve with those dimensions. JPEG was the winning format, and they worked on reducing the file size even further by making the mobile client prepend a common header image and only transmit the basic image data.</p>
<h2 id="Taking-this-approach-to-the-web"><a href="#Taking-this-approach-to-the-web" class="headerlink" title="Taking this approach to the web"></a>Taking this approach to the web</h2><p>If we want to use the same technique on a website, we need to:</p>
<ol>
<li>Send image data.</li>
<li>Send the header.</li>
<li>Send the JS code that will glue the header and the data together.</li>
</ol>
<p>In the case of a mobile app, the code for (2) and (3) is shipped as part of the app. But in a website we need to send it as part of the response. This means that, at least the first time the user visits our page, there won’t be large savings using this technique. For subsequent requests, we could use cached JS or a Service Worker to do the glueing process.</p>
<p>But not everything is lost.</p>
<h2 id="Using-a-different-image-format"><a href="#Using-a-different-image-format" class="headerlink" title="Using a different image format"></a>Using a different image format</h2><p>I wondered how other format files performed in file size when saving small files. I tried with PNG and GIF, and both of them were larger than JPG. Then I have it a try to WebP and I was surprised on how well it compresses images.</p>
<h3 id="How-I-resized-and-compressed-the-images"><a href="#How-I-resized-and-compressed-the-images" class="headerlink" title="How I resized and compressed the images"></a>How I resized and compressed the images</h3><p><strong><a href="/demos/webp-preview/">In this page</a> you can see the demo and all the source images generated</strong></p>
<p>First, I downloaded some 64×64px cover art images using the <a href="https://developer.spotify.com/web-api/console/get-artist-albums/?id=61C3cEhdoJ9YiQSQSwYB4K">Spotify Web API</a>. I wanted to use square images with a consistent small size.</p>
<p>Then I used Photoshop to create a 42×42px JPEG version of the files, with the minimum quality settings (that is, max compression). Then I passed them through <a href="https://imageoptim.com/">ImageOptim</a>, that saved around 66% of the file size using a lossless optimization. The final average file size is 478 bytes.
<a href="/assets/images/posts/imageoptim-jpg-optimization.png"><img src="/assets/images/posts/imageoptim-jpg-optimization.png" alt="ImageOptim squeezing JPGs"></a></p>
<p>Note that Facebook don’t mention what the size for their images was:</p>
<blockquote>
<p>“Unfortunately, the standard JPEG header is hundreds of bytes in size. In fact, the JPEG header alone is several times bigger than our entire 200-byte budget. However, excluding the JPEG header, the encoded data payload itself was approaching our 200 bytes” - taken from <a href="https://code.facebook.com/posts/991252547593574/the-technology-behind-preview-photos/">The technology behind preview photos</a>.</p>
</blockquote>
<p>For the WebP version I used Photoshop to create a 42×42 px JPEG version of the files, but this time with the maximum quality settings. This is to make sure that I didn’t introduce artifacts that WebP had to encode. Then again, I passed the files through ImageOptim, reducing the file size around 25%, to an average of 2.5kB.</p>
<p>Finally, I run <a href="https://developers.google.com/speed/webp/docs/using"><code>cwebp</code></a> to generate WebP images from the JPEG version, with the minimum quality:</p>
<pre class=" language-bash"><code class="language-bash"><span class="token keyword">for</span> f <span class="token keyword">in</span> *.jpg<span class="token punctuation">;</span> <span class="token keyword">do</span> cwebp -q 0 <span class="token variable">$f</span> -o <span class="token string">"<span class="token variable"><span class="token variable">$(</span><span class="token function">basename</span> $f .jpg<span class="token variable">)</span></span>"</span>.webp<span class="token punctuation">;</span> <span class="token keyword">done</span>
</code></pre>
<p>The resulting WebP images have a file size between 90 and 202 bytes, with an average of 121 bytes. That is <strong>25% of an equivalent JPG image</strong>.
<a href="/assets/images/posts/webp-vs-jpeg-preview-photos.jpg"><img src="/assets/images/posts/webp-vs-jpeg-preview-photos.jpg" alt="WebP vs JPEG encoding tiny placeholder images"></a></p>
<p>The artifacts generated by JPEG and WebP are quite different, but in any case, when smoothed using blur, they look almost identical:
<a href="/assets/images/posts/webp-vs-jpeg-preview-photos-blur.jpg"><img src="/assets/images/posts/webp-vs-jpeg-preview-photos-blur.jpg" alt="WebP vs JPEG encoding tiny placeholder images after applying a small blur effect"></a></p>
<p>Remember that these images are always shown with a blur effect, to smooth artifacts and pixels.</p>
<h3 id="Medium’s-Progressive-Loading-Inlined-WebP"><a href="#Medium’s-Progressive-Loading-Inlined-WebP" class="headerlink" title="Medium’s Progressive Loading + Inlined WebP"></a>Medium’s Progressive Loading + Inlined WebP</h3><p>I have forked the CodePen I created on <a href="/medium-image-progressive-loading-placeholder/">How Medium does progressive image loading</a> to show how it works with WebP. You will need a browser that supports WebP to see the full effect. Otherwise, you can <a href="/assets/images/posts/webp-progressive-image-loading.mp4">watch this video</a> showing the effect.</p>
<p>I have resized the original image to a 42×28px thumbnail, converted to WebP and generated its Data URI:</p>
<pre><code>data:image/webp;base64,UklGRnoAAABXRUJQVlA4IG4AAABQBQCdASoqABwAP/3+/3+/urWyMBVYA/A/iWIAAR7p/Y3etgh4KD8QqXEZj6waibITSIAA/cndnUz4/z4LEgByYUql75Cq/12W33KFIKQpc8L0Dt19C7NFXin0tKlxd70dzSF978msbuqLjDgAAA==
</code></pre>
<p>That’s 199 characters. And this is the result:</p>
<iframe id="cp_embed_QjeWVv" src="//codepen.io/jmperez/embed/QjeWVv?height=403&theme-id=0&slug-hash=QjeWVv&default-tab=result" scrolling="no" frameborder="no" height="403" allowTransparency="true" allowfullscreen="true" class="cp_embed_iframe" data-amp-width="100%" style="width: 100%; overflow: hidden;"></iframe>

<p>You can see it better <a href="http://codepen.io/jmperez/full/QjeWVv/">in full screen</a>. I recommend that you use network throttling and disable cache to notice the full animation.</p>
<h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>We have managed to create a file within the 200 bytes budget without having to mess with the headers nor fancy low-level hacks. <em>Here’s when I wonder if it would be possible to strip the header of the WebP files and get even higher savings</em>.</p>
<p>For the web, <a href="http://caniuse.com/#feat=webp">WebP can only be used in Chrome and Opera</a>, which limits its applicability in the real world. Interestingly for Facebook’s use case, WebP is supported on native mobile apps on <a href="https://github.com/carsonmcdonald/WebP-iOS-example">iOS</a> and <a href="https://github.com/EverythingMe/webp-android">Android</a>, so they could well use WebP as an alternative to their <em>technology</em>.</p>
]]></content>
    
    <summary type="html">
    
      Following with the image optimization topic, I am going to have a deeper look to Facebook&#39;s technique to create preview photos, and will show how WebP can simplify their solution.
    
    </summary>
    
    
      <category term="facebook" scheme="https://jmperezperez.com/tags/facebook/"/>
    
      <category term="images" scheme="https://jmperezperez.com/tags/images/"/>
    
      <category term="ux" scheme="https://jmperezperez.com/tags/ux/"/>
    
      <category term="webp" scheme="https://jmperezperez.com/tags/webp/"/>
    
  </entry>
  
  <entry>
    <title>How Medium does progressive image loading</title>
    <link href="https://jmperezperez.com//medium-image-progressive-loading-placeholder"/>
    <id>https://jmperezperez.com//medium-image-progressive-loading-placeholder</id>
    <published>2015-10-18T20:05:00.000Z</published>
    <updated>2021-12-14T07:52:53.526Z</updated>
    
    <content type="html"><![CDATA[<p>Recently, I was browsing a post on Medium and I spotted a nice image loading effect. First, load a small blurry image, and then transition to the large image. I found it pretty neat and wanted to dissect how it was done.</p>
<p><img
    loading="lazy"
    src="https://res.cloudinary.com/jmperez/image/upload/w_auto,f_auto,c_scale/v1510693577/medium-placeholder_ciusf2.png"
    sizes="(max-width: 768px) 100vw, 684px" alt="A screenshot of a blurry placeholder while the image is loaded" style="margin: 0 auto "/></p>
<span id="more"></span>

<h2 id="Medium’s-technique"><a href="#Medium’s-technique" class="headerlink" title="Medium’s technique"></a>Medium’s technique</h2><p>To see how image loading works in Medium, it is best to see a demo:</p>
<video controls style="max-width:100%" width="854" height="480">
  <source src="/assets/images/posts/medium-progressive-loading.mp4" type="video/mp4">
</video>

<p>I have performed a <a href="http://www.webpagetest.org/video/compare.php?tests=151018_XD_KDF-r:1-c:0">WebPageTest test</a> against <a href="https://medium.com/backchannel/exclusive-why-apple-is-still-sweating-the-details-on-imac-531a95e50c91">this page on Medium</a> where you can see how it loads too. And if you want to see it by yourself, open Medium’s post in your browser, disable the cache and throttle the response so it takes longer to fetch the images and you can see the effect.</p>
<p>Here is what is going on:</p>
<ol>
<li><p><strong>Render a div where the image will be displayed</strong>. Medium uses a <code>&lt;div/&gt;</code> with a <code>padding-bottom</code> set to a percentage, which corresponds to the aspect ratio of the image. Thus, they prevent reflows while the images are loaded since everything is rendered in its final position. This has also been referred to as <a href="http://daverupert.com/2015/12/intrinsic-placeholders-with-picture/">intrinsic placeholders</a>.</p>
</li>
<li><p><strong>Load a tiny version of the image</strong>. At the moment, they seem to be requesting small JPEG thumbnails with a very low quality (e.g. 20%). The markup for this small image is returned in the initial HTML as an <code>&lt;img/&gt;</code>, so the browser starts fetching them right away.</p>
</li>
<li><p>Once the image is loaded, <strong>it is drawn in a <code>&lt;canvas/&gt;</code></strong>. Then, the image data is taken and passed through a custom <code>blur()</code> function You can see it, a bit scrambled, in the <code>main-base.bundle</code> JS file. This function is similar, though not identical, to <a href="http://www.quasimondo.com/StackBlurForCanvas/StackBlurDemo.html">StackBlur</a>‘s blur function. At the same time, <strong>the main image is requested</strong>.</p>
</li>
<li><p>Once the main image is loaded, <strong>it is shown</strong> and the <code>canvas</code> is hidden.</p>
</li>
</ol>
<p>All the transitions are quite smooth, thanks to the CSS animations applied.</p>
<h2 id="Markup"><a href="#Markup" class="headerlink" title="Markup"></a>Markup</h2><p>A bird’s eye view of the markup for an image:</p>
<pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>figure</span><span class="token punctuation">></span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token punctuation">/></span></span>
    <span class="token comment" spellcheck="true">&lt;!-- this div keeps the aspect ratio so the placeholder doesn't collapse --></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>img</span> <span class="token punctuation">/></span></span>
    <span class="token comment" spellcheck="true">&lt;!-- this is a tiny image with a resolution of e.g. ~27x17 and low quality --></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>canvas</span> <span class="token punctuation">/></span></span>
    <span class="token comment" spellcheck="true">&lt;!-- takes the above image and applies a blur filter --></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>img</span> <span class="token punctuation">/></span></span>
    <span class="token comment" spellcheck="true">&lt;!-- the large image to be displayed --></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>noscript</span> <span class="token punctuation">/></span></span>
    <span class="token comment" spellcheck="true">&lt;!-- fallback for no JS --></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>figure</span><span class="token punctuation">></span></span>
</code></pre>
<p>And a concrete example, so you see what goes in those tags:</p>
<pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>figure</span>
  <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>7012<span class="token punctuation">"</span></span>
  <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>7012<span class="token punctuation">"</span></span>
  <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>graf--figure graf--layoutFillWidth graf-after--h4<span class="token punctuation">"</span></span>
<span class="token punctuation">></span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>aspectRatioPlaceholder is-locked<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>aspect-ratio-fill<span class="token punctuation">"</span></span><span class="token style-attr language-css"><span class="token attr-name"> <span class="token attr-name">style</span></span><span class="token punctuation">="</span><span class="token attr-value"><span class="token property">padding-bottom</span><span class="token punctuation">:</span> <span class="token number">66.7%</span><span class="token punctuation">;</span></span><span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span>
      <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>progressiveMedia js-progressiveMedia graf-image is-canvasLoaded is-imageLoaded<span class="token punctuation">"</span></span>
      <span class="token attr-name">data-image-id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>1*sg-uLNm73whmdOgKlrQdZA.jpeg<span class="token punctuation">"</span></span>
      <span class="token attr-name">data-width</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>2000<span class="token punctuation">"</span></span>
      <span class="token attr-name">data-height</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>1333<span class="token punctuation">"</span></span>
      <span class="token attr-name">data-scroll</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>native<span class="token punctuation">"</span></span>
    <span class="token punctuation">></span></span>
      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>img</span>
        <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>https://cdn-images-1.medium.com/freeze/max/27/1*sg-uLNm73whmdOgKlrQdZA.jpeg?q<span class="token punctuation">=</span>20<span class="token punctuation">"</span></span>
        <span class="token attr-name">crossorigin</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>anonymous<span class="token punctuation">"</span></span>
        <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>progressiveMedia-thumbnail js-progressiveMedia-thumbnail<span class="token punctuation">"</span></span>
      <span class="token punctuation">/></span></span>
      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>canvas</span>
        <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>progressiveMedia-canvas js-progressiveMedia-canvas<span class="token punctuation">"</span></span>
        <span class="token attr-name">width</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>75<span class="token punctuation">"</span></span>
        <span class="token attr-name">height</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>47<span class="token punctuation">"</span></span>
      <span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>canvas</span><span class="token punctuation">></span></span>
      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>img</span>
        <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>progressiveMedia-image js-progressiveMedia-image __web-inspector-hide-shortcut__<span class="token punctuation">"</span></span>
        <span class="token attr-name">data-src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>https://cdn-images-1.medium.com/max/1800/1*sg-uLNm73whmdOgKlrQdZA.jpeg<span class="token punctuation">"</span></span>
        <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>https://cdn-images-1.medium.com/max/1800/1*sg-uLNm73whmdOgKlrQdZA.jpeg<span class="token punctuation">"</span></span>
      <span class="token punctuation">/></span></span>
      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>noscript</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>js-progressiveMedia-inner<span class="token punctuation">"</span></span>
        <span class="token punctuation">></span></span><span class="token entity" title="&lt;">&amp;lt;</span>img class="progressiveMedia-noscript js-progressiveMedia-inner"
        src="https://cdn-images-1.medium.com/max/1800/1*sg-uLNm73whmdOgKlrQdZA.jpeg"<span class="token entity" title="&gt;">&amp;gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>noscript</span>
      <span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>figure</span><span class="token punctuation">></span></span>
</code></pre>
<p><em>Note that the actual image sizes requested depend on the device.</em></p>
<h2 id="An-attempt-to-reproduce-the-effect"><a href="#An-attempt-to-reproduce-the-effect" class="headerlink" title="An attempt to reproduce the effect"></a>An attempt to reproduce the effect</h2><p>I have prepared <a href="http://codepen.io/jmperez/pen/yYjPER">this CodePen</a> where I have implemented the same effect, though using CSS filters for the blur instead of a canvas (see below more info about this variant).</p>
<p>Here is a demo (click ‘Run Pen’ to run it):</p>
<iframe id="cp_embed_yYjPER" src="//codepen.io/jmperez/embed/preview/yYjPER?height=403&theme-id=0&slug-hash=yYjPER&default-tab=result" scrolling="no" frameborder="no" height="403" allowTransparency="true" allowfullscreen="true" class="cp_embed_iframe" data-amp-width="100%" style="width: 100%; overflow: hidden;"></iframe>

<p>You can see it better <a href="http://codepen.io/jmperez/full/Xmzobe/">in full screen</a>. I recommend that you use network throttling and disable cache to notice the full animation.</p>
<p>This filmstrip view shows the above codepen when disabling cache and throttling to “Good 3G”:
<img src="/assets/images/posts/medium-codepen.png" alt="Chrome Inspector Timeline Capture"></p>
<h2 id="Is-it-worth-it"><a href="#Is-it-worth-it" class="headerlink" title="Is it worth it?"></a>Is it worth it?</h2><p>Clearly, there is a lot of things going on to be able to render an image this way, and it can be discouraging to do something similar on your site. A few years ago it would have been impossible to do this animations and blur effects in a performant way, but the truth is that most of the times the latency is the bottleneck, not the device capabilities, and we can play with these visual explorations.</p>
<p>Having full control of the loading of images has some advantages:</p>
<ul>
<li><p><strong>Lazy loading</strong>. Using JS for making the requests allows them to be in control of what images are requested. While all the small thumbnails are requested, the large images are only requests when they are within the viewport.</p>
</li>
<li><p><strong>Better placeholder</strong>. The thumbnails are very small, barely 2kB, which combined with the blurry effect allows for a better placeholder than a solid colour, without sacrificing payload.</p>
</li>
<li><p><strong>Tailored image sizes</strong>. Medium serves different images sizes depending on the device that makes the requests, which optimises the weight of the page.</p>
</li>
</ul>
<h2 id="Variants"><a href="#Variants" class="headerlink" title="Variants"></a>Variants</h2><p>Before finding out about this technique, I thought of using a similar approach for a site I’m working on.</p>
<h3 id="Inlining-image-data"><a href="#Inlining-image-data" class="headerlink" title="Inlining image data"></a>Inlining image data</h3><p>Instead of making a request for the small thumbnails, it is possible to inline them using data URIs. This increases the size of the HTML, but accelerates the rendering of the placeholder, which is immediate one the markup is downloaded. The blur effect allows these images to be really small. I did some tests with 0.5kB size images, and the result was similar to using a 4x larger image.</p>
<h3 id="Blur-effect"><a href="#Blur-effect" class="headerlink" title="Blur effect"></a>Blur effect</h3><p>By default, when a browser renders a small image scaled up, it applies a light blur effect to smooth the artefacts of the image. The effect can also be <a href="http://superuser.com/questions/530317/how-to-prevent-chrome-from-blurring-small-images-when-zoomed-in">turned off</a> for images like QR codes.</p>
<blockquote>
<p>[…]the browser would render it in a way that didn’t make it look blocky[…] from <a href="https://developers.google.com/web/updates/2015/01/pixelated">Google Developers</a>.</p>
</blockquote>
<p>This works both in Chrome, Safari and Firefox (I haven’t tried on IE yet), though the smoothing effect is more prominent in Chrome. Here is a demo, but you can see it better <a href="http://codepen.io/jmperez/full/Xmzobe/">in full screen</a>:</p>
<iframe id="cp_embed_Xmzobe" src="//codepen.io/jmperez/embed/Xmzobe?height=367&theme-id=0&slug-hash=Xmzobe&default-tab=result" scrolling="no" frameborder="no" height="367" allowTransparency="true" allowfullscreen="true" class="cp_embed_iframe" data-amp-width="100%" style="width: 100%; overflow: hidden;"></iframe>

<p>Note how the artefacts are smoothen. Keep in mind that the image is only 27px wide and has very low quality, which should result in an awful scaled-up version, but it isn’t. If the above effect is enough for you, then you don’t need to use more complicated alternatives.</p>
<p>The blur effect can also be achieved using <a href="https://codepen.io/aniketpant/pen/DsEve">CSS Filter Effects</a>. <a href="https://caniuse.com/#feat=css-filters">Its support is quite wide</a> aside from IE. I’m pretty sure Medium tried this before going to a canvas solution, which feels far too over-engineered, but for some reason they decided not to use it.</p>
<iframe id="cp_embed_PPOXzY" src="//codepen.io/jmperez/embed/PPOXzY?height=367&theme-id=0&slug-hash=PPOXzY&default-tab=result" scrolling="no" frameborder="no" height="367" allowTransparency="true" allowfullscreen="true" class="cp_embed_iframe" data-amp-width="100%" style="width: 100%; overflow: hidden;"></iframe>

<p>The advantage of this technique is that you can easily tweak how much blur you want and everything is achieved using CSS.</p>
<p>Another option is to use a SVG filter, as explained in <a href="https://css-tricks.com/the-blur-up-technique-for-loading-background-images/">The “Blur Up” Technique for Loading Background Images</a> and <a href="http://rentafounder.com/textured-gradients-in-pure-css/">Textured Gradients in Pure CSS</a>.</p>
<h3 id="Other-ways-of-improving-placeholders-Google-Images-Search"><a href="#Other-ways-of-improving-placeholders-Google-Images-Search" class="headerlink" title="Other ways of improving placeholders: Google Images Search"></a>Other ways of improving placeholders: Google Images Search</h3><p>A simpler technique is used by Google Search when searching for images from a smartphone:
<a href="/assets/images/posts/google-images-placeholder.png"><img src="/assets/images/posts/google-images-placeholder.png" alt="Searching on Google Images from the phone"></a>
<em>&uarr; Google Images Search shows a solid background as placeholder (left image is while loading, right when already loaded).</em></p>
<p>They pick a colour (maybe the dominant colour of the picture?) and they use it a solid colour background. It gives the user the feeling that images loads faster.</p>
<h3 id="An-even-more-advanced-one-Facebook’s-200-byte-technique"><a href="#An-even-more-advanced-one-Facebook’s-200-byte-technique" class="headerlink" title="An even more advanced one: Facebook’s 200 byte technique"></a>An even more advanced one: Facebook’s 200 byte technique</h3><p>Earlier this year Facebook posted “<a href="https://code.facebook.com/posts/991252547593574/the-technology-behind-preview-photos/">The technology behind preview photos</a>“, an interesting article about serving 42 x 42px image previews without the JPEG header.</p>
<p>The scenario is a bit different, since these “images” are served to the Facebook mobile client, which knows how to prepend the header to compose a valid JPEG image. In the case of a website, we would need to compose this using Javascript, which would probably remove most of the savings. A solution would be to use a Service Worker to do the composition, though we would still need some Javascript to send a “request” with the image contents.</p>
<p>In any case, it seems a bit overkilling for the web, but I wanted to include it as a reference. <a href="/webp-placeholder-images/">Using WebP for generating this preview images</a> can lead to similar savings without having to resort to “creative” solutions.</p>
<h3 id="LQIP-Low-Quality-Image-Placeholders"><a href="#LQIP-Low-Quality-Image-Placeholders" class="headerlink" title="LQIP: Low Quality Image Placeholders"></a>LQIP: Low Quality Image Placeholders</h3><p>Instead of waiting for the final image to be rendered, we can serve a highly compressed image first, and then switch to the large one. This is what <a href="http://www.guypo.com/introducing-lqip-low-quality-image-placeholders/">Low Quality Image Placeholders (LQIP)</a> consists of. The idea is similar to Medium’s, but serving an image with the same dimensions but higher compression.</p>
<h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>As our pages load more and more images, it is good to think of their loading process on our pages, since it affects performance and user experience.</p>
<p>If you are generating several thumbnail sizes for your images, you can experiment using a very small one to use it as the background while the final image loads.</p>
<div class="read-next">
<p><strong>Related Posts</strong></p>
<ul>
<li>I gave a talk at CSSConf about progressive images. You can watch the video and slides on <a href="/cssconf-au-2016/">Speaking at CSSConf Australia 2016</a>.</li>
<li>I collected more examples of sites using a similar technique on <a href="/more-progressive-image-loading/">More examples of Progressive Image Loading</a> and <a href="/svg-placeholders/">How to use SVG as a Placeholder</a>.</li>
<li>Interested in other image tips and tricks? Check out <a href="/image-optimization-lossy-lossless-techniques/">Image optimization: Lossy, lossless and other techniques</a>.
</li>
</ul>
</div>
]]></content>
    
    <summary type="html">
    
      This post explains how Medium renders an image placeholder using low-res thumbnails and canvas
    
    </summary>
    
    
      <category term="images" scheme="https://jmperezperez.com/tags/images/"/>
    
      <category term="ux" scheme="https://jmperezperez.com/tags/ux/"/>
    
  </entry>
  
</feed>
