<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Jose M. Perez&#39;s Blog</title>
  <subtitle>Web development, performance, and some other good practices.</subtitle>
  <link href="/tag/webp/atom.xml" rel="self"/>
  
  <link href="https://jmperezperez.com/"/>
  <updated>2018-12-16T17:51:46.000Z</updated>
  <id>https://jmperezperez.com/</id>
  
  <author>
    <name>Jose M. Perez</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Using WebP to create tiny preview images</title>
    <link href="https://jmperezperez.com//webp-placeholder-images"/>
    <id>https://jmperezperez.com//webp-placeholder-images</id>
    <published>2015-11-28T10:30:00.000Z</published>
    <updated>2018-12-16T17:51:46.000Z</updated>
    
    <content type="html"><![CDATA[<p>Following with the image optimization topic, I am going to have a deeper look to <a href="https://code.facebook.com/posts/991252547593574/the-technology-behind-preview-photos/">Facebook’s technique to create <em>preview</em> photos</a>, and will show how WebP can simplify their solution.</p>
<p><img src="/assets/images/posts/webp-vs-jpeg-preview-photos.jpg" alt="WebP vs JPEG when encoding tiny images"></p>
<p><strong>tl;dr</strong> WebP produces tiny files when compressing small images. This makes it ideal for implementing <em>preview photos</em>. <a href="/demos/webp-preview/">Check the demo</a>.</p>
<span id="more"></span>
<p>In a recent article I talked about <a href="/medium-image-progressive-loading-placeholder/">an image loading technique used by Medium</a> that combined a small blurry preview plus a transition to the final image. This approach has been used for some time by other sites and mobile applications, and it is getting even more focus these days as major websites try to expand in countries with very slow internet connections.</p>
<p>Facebook is one of them and explained some months ago <a href="https://code.facebook.com/posts/991252547593574/the-technology-behind-preview-photos/">how they inlined preview photos</a>.</p>
<h2 id="Finding-out-the-right-image-dimensions"><a href="#Finding-out-the-right-image-dimensions" class="headerlink" title="Finding out the right image dimensions"></a>Finding out the right image dimensions</h2><p>There is a direct relation between the dimensions of the image, its size in bytes, and the radius for the blur effect that needs to be applied to smooth the big upscaled pixels. In addition, we need to take into account the rendered dimensions of the image: we will want a larger preview the larger the rendered size is.</p>
<p>Facebook found that, for their mobile client, the sweet spot for the preview size was 42×42px. Then, they tried to generate the smallest (in bytes) image that they could serve with those dimensions. JPEG was the winning format, and they worked on reducing the file size even further by making the mobile client prepend a common header image and only transmit the basic image data.</p>
<h2 id="Taking-this-approach-to-the-web"><a href="#Taking-this-approach-to-the-web" class="headerlink" title="Taking this approach to the web"></a>Taking this approach to the web</h2><p>If we want to use the same technique on a website, we need to:</p>
<ol>
<li>Send image data.</li>
<li>Send the header.</li>
<li>Send the JS code that will glue the header and the data together.</li>
</ol>
<p>In the case of a mobile app, the code for (2) and (3) is shipped as part of the app. But in a website we need to send it as part of the response. This means that, at least the first time the user visits our page, there won’t be large savings using this technique. For subsequent requests, we could use cached JS or a Service Worker to do the glueing process.</p>
<p>But not everything is lost.</p>
<h2 id="Using-a-different-image-format"><a href="#Using-a-different-image-format" class="headerlink" title="Using a different image format"></a>Using a different image format</h2><p>I wondered how other format files performed in file size when saving small files. I tried with PNG and GIF, and both of them were larger than JPG. Then I have it a try to WebP and I was surprised on how well it compresses images.</p>
<h3 id="How-I-resized-and-compressed-the-images"><a href="#How-I-resized-and-compressed-the-images" class="headerlink" title="How I resized and compressed the images"></a>How I resized and compressed the images</h3><p><strong><a href="/demos/webp-preview/">In this page</a> you can see the demo and all the source images generated</strong></p>
<p>First, I downloaded some 64×64px cover art images using the <a href="https://developer.spotify.com/web-api/console/get-artist-albums/?id=61C3cEhdoJ9YiQSQSwYB4K">Spotify Web API</a>. I wanted to use square images with a consistent small size.</p>
<p>Then I used Photoshop to create a 42×42px JPEG version of the files, with the minimum quality settings (that is, max compression). Then I passed them through <a href="https://imageoptim.com/">ImageOptim</a>, that saved around 66% of the file size using a lossless optimization. The final average file size is 478 bytes.
<a href="/assets/images/posts/imageoptim-jpg-optimization.png"><img src="/assets/images/posts/imageoptim-jpg-optimization.png" alt="ImageOptim squeezing JPGs"></a></p>
<p>Note that Facebook don’t mention what the size for their images was:</p>
<blockquote>
<p>“Unfortunately, the standard JPEG header is hundreds of bytes in size. In fact, the JPEG header alone is several times bigger than our entire 200-byte budget. However, excluding the JPEG header, the encoded data payload itself was approaching our 200 bytes” - taken from <a href="https://code.facebook.com/posts/991252547593574/the-technology-behind-preview-photos/">The technology behind preview photos</a>.</p>
</blockquote>
<p>For the WebP version I used Photoshop to create a 42×42 px JPEG version of the files, but this time with the maximum quality settings. This is to make sure that I didn’t introduce artifacts that WebP had to encode. Then again, I passed the files through ImageOptim, reducing the file size around 25%, to an average of 2.5kB.</p>
<p>Finally, I run <a href="https://developers.google.com/speed/webp/docs/using"><code>cwebp</code></a> to generate WebP images from the JPEG version, with the minimum quality:</p>
<pre class=" language-bash"><code class="language-bash"><span class="token keyword">for</span> f <span class="token keyword">in</span> *.jpg<span class="token punctuation">;</span> <span class="token keyword">do</span> cwebp -q 0 <span class="token variable">$f</span> -o <span class="token string">"<span class="token variable"><span class="token variable">$(</span><span class="token function">basename</span> $f .jpg<span class="token variable">)</span></span>"</span>.webp<span class="token punctuation">;</span> <span class="token keyword">done</span>
</code></pre>
<p>The resulting WebP images have a file size between 90 and 202 bytes, with an average of 121 bytes. That is <strong>25% of an equivalent JPG image</strong>.
<a href="/assets/images/posts/webp-vs-jpeg-preview-photos.jpg"><img src="/assets/images/posts/webp-vs-jpeg-preview-photos.jpg" alt="WebP vs JPEG encoding tiny placeholder images"></a></p>
<p>The artifacts generated by JPEG and WebP are quite different, but in any case, when smoothed using blur, they look almost identical:
<a href="/assets/images/posts/webp-vs-jpeg-preview-photos-blur.jpg"><img src="/assets/images/posts/webp-vs-jpeg-preview-photos-blur.jpg" alt="WebP vs JPEG encoding tiny placeholder images after applying a small blur effect"></a></p>
<p>Remember that these images are always shown with a blur effect, to smooth artifacts and pixels.</p>
<h3 id="Medium’s-Progressive-Loading-Inlined-WebP"><a href="#Medium’s-Progressive-Loading-Inlined-WebP" class="headerlink" title="Medium’s Progressive Loading + Inlined WebP"></a>Medium’s Progressive Loading + Inlined WebP</h3><p>I have forked the CodePen I created on <a href="/medium-image-progressive-loading-placeholder/">How Medium does progressive image loading</a> to show how it works with WebP. You will need a browser that supports WebP to see the full effect. Otherwise, you can <a href="/assets/images/posts/webp-progressive-image-loading.mp4">watch this video</a> showing the effect.</p>
<p>I have resized the original image to a 42×28px thumbnail, converted to WebP and generated its Data URI:</p>
<pre><code>data:image/webp;base64,UklGRnoAAABXRUJQVlA4IG4AAABQBQCdASoqABwAP/3+/3+/urWyMBVYA/A/iWIAAR7p/Y3etgh4KD8QqXEZj6waibITSIAA/cndnUz4/z4LEgByYUql75Cq/12W33KFIKQpc8L0Dt19C7NFXin0tKlxd70dzSF978msbuqLjDgAAA==
</code></pre>
<p>That’s 199 characters. And this is the result:</p>
<iframe id="cp_embed_QjeWVv" src="//codepen.io/jmperez/embed/QjeWVv?height=403&theme-id=0&slug-hash=QjeWVv&default-tab=result" scrolling="no" frameborder="no" height="403" allowTransparency="true" allowfullscreen="true" class="cp_embed_iframe" data-amp-width="100%" style="width: 100%; overflow: hidden;"></iframe>

<p>You can see it better <a href="http://codepen.io/jmperez/full/QjeWVv/">in full screen</a>. I recommend that you use network throttling and disable cache to notice the full animation.</p>
<h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>We have managed to create a file within the 200 bytes budget without having to mess with the headers nor fancy low-level hacks. <em>Here’s when I wonder if it would be possible to strip the header of the WebP files and get even higher savings</em>.</p>
<p>For the web, <a href="http://caniuse.com/#feat=webp">WebP can only be used in Chrome and Opera</a>, which limits its applicability in the real world. Interestingly for Facebook’s use case, WebP is supported on native mobile apps on <a href="https://github.com/carsonmcdonald/WebP-iOS-example">iOS</a> and <a href="https://github.com/EverythingMe/webp-android">Android</a>, so they could well use WebP as an alternative to their <em>technology</em>.</p>
]]></content>
    
    <summary type="html">
    
      Following with the image optimization topic, I am going to have a deeper look to Facebook&#39;s technique to create preview photos, and will show how WebP can simplify their solution.
    
    </summary>
    
    
      <category term="images" scheme="https://jmperezperez.com/tags/images/"/>
    
      <category term="facebook" scheme="https://jmperezperez.com/tags/facebook/"/>
    
      <category term="ux" scheme="https://jmperezperez.com/tags/ux/"/>
    
      <category term="webp" scheme="https://jmperezperez.com/tags/webp/"/>
    
  </entry>
  
</feed>
